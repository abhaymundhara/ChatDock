<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChatDock</title>
    <link rel="stylesheet" href="styles/ace-ui.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@500&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- Drag handle removed in favor of whole-bar dragging via CSS -->

    <div class="ace-bar" id="aceBar">
      <!-- Input Row (Always Visible) -->
      <div class="input-row">
        <div class="bar-icon" id="mainIcon">
          <svg viewBox="0 0 24 24">
            <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="white" />
            <path
              d="M2 17L12 22L22 17"
              stroke="white"
              stroke-width="2"
              fill="none"
            />
            <path
              d="M2 12L12 17L22 12"
              stroke="white"
              stroke-width="2"
              fill="none"
            />
          </svg>
        </div>

        <input
          type="text"
          class="bar-input"
          id="chatInput"
          placeholder="Type a command or ask a question..."
          autocomplete="off"
          autofocus
        />

        <div class="bar-actions">
          <button class="settings-btn" id="settingsBtn" title="Settings">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
              <path
                d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.56-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.03-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"
              />
            </svg>
          </button>

          <div class="action-badge" id="statusBadge" style="display: none">
            Ready
          </div>
        </div>
      </div>

      <!-- Command Palette (shown when typing /) -->
      <div class="command-palette" id="commandPalette" style="display: none">
        <!-- Dynamic command items -->
      </div>

      <!-- Expanded Content -->
      <div class="expanded-content" id="expandedList">
        <div class="workflow-strip" id="workflowStrip" style="display: none">
          <div class="workflow-steps" id="workflowSteps"></div>
        </div>
        <div class="tasks-strip" id="tasksStrip" style="display: none">
          <div class="tasks-list" id="tasksList"></div>
        </div>
        <div class="messages-list" id="messagesList"></div>
      </div>
    </div>

    <script>
      // ===== Configuration =====
      const CHAT_BASE =
        (window.__CHAT_BASE__ &&
          window.__CHAT_BASE__.get &&
          window.__CHAT_BASE__.get()) ||
        "http://127.0.0.1:3001";
      const CHAT_AUTH =
        (window.__CHAT_AUTH__ &&
          window.__CHAT_AUTH__.get &&
          window.__CHAT_AUTH__.get()) ||
        {};

      // ===== DOM Elements =====
      const aceBar = document.getElementById("aceBar");
      const chatInput = document.getElementById("chatInput");
      const expandedList = document.getElementById("expandedList");
      const messagesList = document.getElementById("messagesList");
      const workflowStrip = document.getElementById("workflowStrip");
      const workflowSteps = document.getElementById("workflowSteps");
      const tasksStrip = document.getElementById("tasksStrip");
      const tasksList = document.getElementById("tasksList");
      const mainIcon = document.getElementById("mainIcon");
      const statusBadge = document.getElementById("statusBadge");
      const settingsBtn = document.getElementById("settingsBtn");
      const commandPalette = document.getElementById("commandPalette");

      // ===== State =====
      let isProcessing = false;
      let currentModels = [];
      let currentModel = "";
      let selectedCommandIndex = 0;
      let currentTasks = [];
      let currentDependencies = {};
      let conversationHistory = []; // Track conversation for context
      const WORKFLOW_STEPS = [
        { key: "tasks", label: "Tasks" },
        { key: "tool_finder", label: "ToolFinder" },
        { key: "tool_call", label: "Tool Call" },
      ];
      const WORKFLOW_STATUSES = ["pending", "active", "complete"];
      const PLANNING_TOOLS = new Set(["task_write", "think", "ask_user"]);
      let workflowState = WORKFLOW_STEPS.reduce((acc, step) => {
        acc[step.key] = "pending";
        return acc;
      }, {});

      // ===== Available Commands =====
      const COMMANDS = [
        { name: "/help", description: "Show available commands", icon: "â“" },
        { name: "/model", description: "Switch AI model", icon: "ðŸ¤–" },
        { name: "/tools", description: "Show all tools", icon: "ðŸ”§" },
        { name: "/skills", description: "Show all skills", icon: "âš¡" },
        { name: "/clear", description: "Clear conversation", icon: "ðŸ—‘ï¸" },
      ];

      // ===== Initial Setup =====
      chatInput.focus();
      loadModels();

      // ===== Helper Functions =====
      function getAuthHeaders() {
        return CHAT_AUTH || {};
      }

      async function loadModels() {
        try {
          const res = await fetch(`${CHAT_BASE}/models`, {
            headers: getAuthHeaders(),
          });
          const data = await res.json();
          currentModels = data.models || [];
          currentModel =
            data.lastModel ||
            (currentModels.length > 0 ? currentModels[0] : "");
        } catch (e) {
          console.error("Failed to load models:", e);
        }
      }

      function setThinking(thinking) {
        isProcessing = thinking;

        if (thinking) {
          mainIcon.classList.add("loading");
          mainIcon.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 4V2M12 20v2M4 12H2m20 0h-2m-2.05-5.95l-1.41-1.41M5.46 19.95l-1.41-1.41M18.54 18.54l1.41 1.41M5.46 4.05l-1.41 1.41" stroke="currentColor" stroke-width="2" fill="none"/></svg>`;
          statusBadge.style.display = "flex";
          statusBadge.innerText = "Working...";
          statusBadge.classList.remove("completed");
          settingsBtn.style.display = "none";
        } else {
          mainIcon.classList.remove("loading");
          mainIcon.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 2L2 7L12 12L22 7L12 2Z" fill="white"/><path d="M2 17L12 22L22 17" stroke="white" stroke-width="2" fill="none"/><path d="M2 12L12 17L22 12" stroke="white" stroke-width="2" fill="none"/></svg>`;
          statusBadge.style.display = "none";
          settingsBtn.style.display = "flex";
        }
      }

      function expand(shouldExpand) {
        if (shouldExpand) {
          aceBar.classList.add("expanded");
        } else {
          aceBar.classList.remove("expanded");
        }
      }

      const TASK_STATUSES = ["pending", "in_progress", "blocked", "completed"];
      const TASK_STATUS_ICONS = {
        pending: "â—‹",
        in_progress: "â—",
        blocked: "âš ",
        completed: "âœ“",
      };

      function hasTasks() {
        return currentTasks.length > 0;
      }

      function resetWorkflow() {
        workflowState = WORKFLOW_STEPS.reduce((acc, step) => {
          acc[step.key] = "pending";
          return acc;
        }, {});
        renderWorkflow();
      }

      function updateWorkflow(stepKey, status) {
        if (!workflowState[stepKey]) return;
        if (!WORKFLOW_STATUSES.includes(status)) return;
        workflowState[stepKey] = status;
        renderWorkflow();
      }

      function renderWorkflow() {
        const hasProgress = WORKFLOW_STEPS.some(
          (step) => workflowState[step.key] !== "pending",
        );

        if (!hasProgress) {
          workflowStrip.style.display = "none";
          return;
        }

        workflowStrip.style.display = "block";
        workflowSteps.innerHTML = "";

        WORKFLOW_STEPS.forEach((step) => {
          const status = workflowState[step.key];
          const stepEl = document.createElement("div");
          stepEl.className = "workflow-step";
          if (status === "active") stepEl.classList.add("is-active");
          if (status === "complete") stepEl.classList.add("is-complete");

          const tick = document.createElement("span");
          tick.className = "step-tick";
          tick.textContent = status === "complete" ? "âœ“" : "";

          const label = document.createElement("span");
          label.className = "step-label";
          label.textContent = step.label;

          stepEl.appendChild(tick);
          stepEl.appendChild(label);
          workflowSteps.appendChild(stepEl);
        });

        expand(true);
      }

      function updateTaskState(taskId, updates) {
        const idx = currentTasks.findIndex((task) => task.id === taskId);
        if (idx === -1) return;
        currentTasks[idx] = { ...currentTasks[idx], ...updates };
      }

      async function persistTaskUpdate(task, row) {
        try {
          const res = await fetch(`${CHAT_BASE}/tools/execute`, {
            method: "POST",
            headers: {
              ...getAuthHeaders(),
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              name: "task_write",
              params: { mode: "append", tasks: [task] },
            }),
          });

          const data = await res.json().catch(() => ({}));
          if (!res.ok || data?.error) {
            throw new Error(data?.error || `Server error: ${res.status}`);
          }
          row?.classList.remove("task-error");
          return true;
        } catch (err) {
          if (row) {
            row.classList.add("task-error");
            setTimeout(() => row.classList.remove("task-error"), 2000);
          }
          console.error("Failed to save task:", err);
          return false;
        }
      }

      function renderTasks() {
        if (!hasTasks()) {
          tasksStrip.style.display = "none";
          return;
        }

        tasksStrip.style.display = "block";
        tasksList.innerHTML = "";

        // Calculate progress (Claude Cowork-style visibility)
        const completedCount = currentTasks.filter(
          (t) => t.status === "completed",
        ).length;
        const totalCount = currentTasks.length;
        const inProgressTask = currentTasks.find(
          (t) => t.status === "in_progress",
        );

        // Add progress indicator if we have tasks
        if (totalCount > 0) {
          const progressBar = document.createElement("div");
          progressBar.className = "task-progress-bar";
          progressBar.innerHTML = `
            <div class="task-progress-fill" style="width: ${(completedCount / totalCount) * 100}%"></div>
            <div class="task-progress-text">${completedCount}/${totalCount} completed</div>
          `;
          tasksList.appendChild(progressBar);
        }

        currentTasks.forEach((task) => {
          const dependsOn =
            task.dependsOn || currentDependencies[task.id] || [];
          const status = task.status || "pending";
          const title = task.task || task.title || "";

          const row = document.createElement("div");
          row.className = "task-row";
          row.dataset.taskId = task.id;

          // Highlight in-progress task prominently (Claude Cowork-style)
          if (status === "in_progress") {
            row.classList.add("task-active");
          }

          const statusBtn = document.createElement("button");
          statusBtn.className = `task-status status-${status}`;
          statusBtn.dataset.status = status;
          statusBtn.type = "button";
          statusBtn.title = status.replace("_", " ");
          statusBtn.textContent = TASK_STATUS_ICONS[status] || "â—‹";

          statusBtn.addEventListener("click", async () => {
            const currentStatus = statusBtn.dataset.status || "pending";
            const currentIndex = TASK_STATUSES.indexOf(currentStatus);
            const nextStatus =
              TASK_STATUSES[(currentIndex + 1) % TASK_STATUSES.length];
            updateTaskState(task.id, { status: nextStatus });
            statusBtn.className = `task-status status-${nextStatus}`;
            statusBtn.textContent = TASK_STATUS_ICONS[nextStatus];
            statusBtn.title = nextStatus.replace("_", " ");
            statusBtn.dataset.status = nextStatus;
            await persistTaskUpdate({ id: task.id, status: nextStatus }, row);
          });

          const titleEl = document.createElement("div");
          titleEl.className = "task-title";
          titleEl.textContent = title;
          titleEl.dataset.original = title;
          titleEl.contentEditable = "true";
          titleEl.spellcheck = false;

          titleEl.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              event.preventDefault();
              titleEl.blur();
            }
          });

          titleEl.addEventListener("blur", async () => {
            const nextTitle = titleEl.textContent.trim();
            if (!nextTitle || nextTitle === titleEl.dataset.original) return;
            updateTaskState(task.id, { task: nextTitle });
            await persistTaskUpdate({ id: task.id, task: nextTitle }, row);
            titleEl.dataset.original = nextTitle;
          });

          const depsEl = document.createElement("div");
          depsEl.className = "task-deps";
          if (dependsOn.length > 0) {
            depsEl.textContent = `â†³ ${dependsOn.length} deps`;
          } else {
            depsEl.style.display = "none";
          }

          row.appendChild(statusBtn);
          row.appendChild(titleEl);
          row.appendChild(depsEl);
          tasksList.appendChild(row);
        });

        expand(true);
      }

      function showCommandPalette(filter = "") {
        // Check if we're typing /model specifically
        if (
          filter.toLowerCase() === "model" ||
          filter.toLowerCase() === "models"
        ) {
          showModelSelector();
          return;
        }

        const filtered = COMMANDS.filter(
          (cmd) =>
            cmd.name.toLowerCase().includes(filter.toLowerCase()) ||
            cmd.description.toLowerCase().includes(filter.toLowerCase()),
        );

        if (filtered.length === 0) {
          hideCommandPalette();
          return;
        }

        commandPalette.innerHTML = filtered
          .map(
            (cmd, idx) => `
        <div class="command-item ${idx === selectedCommandIndex ? "selected" : ""}" data-command="${cmd.name}">
          <span class="command-icon">${cmd.icon}</span>
          <div class="command-info">
            <div class="command-name">${cmd.name}</div>
            <div class="command-desc">${cmd.description}</div>
          </div>
        </div>
      `,
          )
          .join("");

        commandPalette.style.display = "block";
        setTimeout(() => commandPalette.classList.add("visible"), 10);
        expand(true);

        // Add click handlers
        commandPalette.querySelectorAll(".command-item").forEach((item) => {
          item.addEventListener("click", () => {
            chatInput.value = item.dataset.command;
            hideCommandPalette();
            chatInput.focus();
            sendMessage();
          });
        });
      }

      function showModelSelector() {
        if (currentModels.length === 0) {
          commandPalette.innerHTML =
            '<div class="command-item"><div class="command-info"><div class="command-desc">Loading models...</div></div></div>';
          commandPalette.style.display = "block";
          setTimeout(() => commandPalette.classList.add("visible"), 10);
          expand(true);
          return;
        }

        commandPalette.innerHTML = `
        <div class="model-list">
          ${currentModels
            .map(
              (model) => `
            <div class="model-item ${model === currentModel ? "active" : ""}" data-model="${model}">
              <span>${model}</span>
              ${model === currentModel ? '<span class="checkmark">âœ“</span>' : ""}
            </div>
          `,
            )
            .join("")}
        </div>
      `;

        commandPalette.style.display = "block";
        setTimeout(() => commandPalette.classList.add("visible"), 10);
        expand(true);

        // Add click handlers for model selection
        commandPalette.querySelectorAll(".model-item").forEach((item) => {
          item.addEventListener("click", async () => {
            const selectedModel = item.dataset.model;
            currentModel = selectedModel;

            // Save to server
            try {
              await fetch(`${CHAT_BASE}/models/selected`, {
                method: "POST",
                headers: {
                  ...getAuthHeaders(),
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ model: selectedModel }),
              });
            } catch (e) {
              console.error("Failed to save model:", e);
            }

            // Update UI
            chatInput.value = "";
            hideCommandPalette();
            messagesList.innerHTML = "";
            addMessage(`Switched to model: ${selectedModel}`, "assistant");

            setTimeout(() => {
              messagesList.innerHTML = "";
              expand(false);
            }, 2000);
          });
        });
      }

      function hideCommandPalette() {
        commandPalette.classList.remove("visible");
        setTimeout(() => {
          commandPalette.style.display = "none";
          commandPalette.innerHTML = "";
        }, 250); // Match CSS transition duration
        selectedCommandIndex = 0;
      }

      function addToolItem(name) {
        expand(true);
        const item = document.createElement("div");
        item.className = "tool-item";
        item.innerHTML = `
        <svg class="icon" viewBox="0 0 24 24" fill="currentColor"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.56-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.03-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        <span>Running ${name}...</span>
      `;
        messagesList.insertBefore(item, messagesList.firstChild);
        return item;
      }

      function addMessage(text, type = "assistant", isPreformatted = false) {
        expand(true);
        const msg = document.createElement("div");
        msg.className = `message ${type}`;

        let safe;

        if (isPreformatted) {
          // Content is already HTML-formatted, use as-is
          safe = text;
        } else {
          // 1. Escape HTML first to prevent XSS from user content
          safe = escapeHtml(text);

          // 2. Apply Markdown Formatting (Simple)
          // Bold
          safe = safe.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
          // Inline Code
          safe = safe.replace(/`(.*?)`/g, "<code>$1</code>");
          // Tables (Simple row conversion) | col | col |
          if (safe.includes("|")) {
            const lines = safe.split("\n");
            let inTable = false;
            safe = lines
              .map((line) => {
                if (line.trim().startsWith("|") && line.trim().endsWith("|")) {
                  const cells = line.split("|").filter((c) => c.trim() !== "");
                  const isHeader = line.includes("---");
                  if (isHeader) return ""; // Skip separator lines

                  const htmlCells = cells
                    .map((c) => (isHeader ? `<th>${c}</th>` : `<td>${c}</td>`))
                    .join("");

                  if (!inTable) {
                    inTable = true;
                    return `<table class="md-table"><tr>${htmlCells}</tr>`;
                  }
                  return `<tr>${htmlCells}</tr>`;
                } else {
                  if (inTable) {
                    inTable = false;
                    return `</table><br>${line}`;
                  }
                  return line;
                }
              })
              .join("\n");
            if (inTable) safe += "</table>";
          }

          // Newlines
          safe = safe.replace(/\n/g, "<br>");
        }

        msg.innerHTML = `<div class="message-content">${safe}</div>`;
        messagesList.appendChild(msg);
        expandedList.scrollTop = expandedList.scrollHeight;
      }

      function escapeHtml(text) {
        if (!text) return "";
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // ===== Slash Commands =====
      async function handleSlashCommand(cmd) {
        const parts = cmd.slice(1).split(" ");
        const command = parts[0].toLowerCase();

        if (command === "model" || command === "models") {
          // Model switching is now handled in the palette
          showModelSelector();
          return true;
        }

        if (command === "tools") {
          try {
            const res = await fetch(`${CHAT_BASE}/tools`, {
              headers: getAuthHeaders(),
            });
            const data = await res.json();
            expand(true);
            messagesList.innerHTML = "";
            addMessage(
              `Available tools (${data.count}):\n\n${data.tools
                .slice(0, 20)
                .map((t) => `â€¢ ${t.name}: ${t.description}`)
                .join(
                  "\n",
                )}${data.count > 20 ? `\n\n...and ${data.count - 20} more` : ""}`,
              "assistant",
            );
          } catch (e) {
            addMessage("Error loading tools: " + e.message, "assistant");
          }
          return true;
        }

        if (command === "skills") {
          try {
            const res = await fetch(`${CHAT_BASE}/skills`, {
              headers: getAuthHeaders(),
            });
            const data = await res.json();
            expand(true);
            messagesList.innerHTML = "";
            addMessage(
              `Available skills (${data.count}):\n\n${data.skills.map((s) => `â€¢ ${s.name}: ${s.description}`).join("\n")}`,
              "assistant",
            );
          } catch (e) {
            addMessage("Error loading skills: " + e.message, "assistant");
          }
          return true;
        }

        if (command === "clear") {
          messagesList.innerHTML = "";
          conversationHistory = []; // Clear conversation history
          currentTasks = []; // Clear tasks
          renderTasks();
          expand(false);
          return true;
        }

        if (command === "help") {
          expand(true);
          messagesList.innerHTML = "";
          addMessage(
            `Available commands:\n\n/model - Switch AI model\n/tools - List available tools\n/skills - List available skills\n/clear - Clear conversation\n/help - Show this help`,
            "assistant",
          );
          return true;
        }

        return false;
      }

      // ===== Chat Logic =====
      async function sendMessage() {
        const text = chatInput.value.trim();
        if (!text || isProcessing) return;

        // Handle slash commands
        if (text.startsWith("/")) {
          chatInput.value = "";
          hideCommandPalette();
          const handled = await handleSlashCommand(text);
          if (handled) return;
        }

        setThinking(true);
        resetWorkflow();
        // Don't clear messages - keep conversation visible
        // messagesList.innerHTML = "";
        if (!hasTasks()) {
          expand(false);
        } else {
          expand(true);
        }
        hideCommandPalette();

        // Add user message to UI and history
        addMessage(text, "user");
        conversationHistory.push({ role: "user", content: text });

        chatInput.value = "";
        chatInput.placeholder = "";

        try {
          // Use the agentic endpoint with tool calling AND conversation history
          const response = await fetch(`${CHAT_BASE}/chat/agent`, {
            method: "POST",
            headers: {
              ...getAuthHeaders(),
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              message: text,
              model: currentModel,
              history: conversationHistory.slice(-20), // Send last 20 messages for context
            }),
          });

          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let currentToolItem = null;

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || ""; // Keep incomplete line in buffer

            for (const line of lines) {
              if (!line.trim()) continue;

              try {
                const event = JSON.parse(line);

                if (event.type === "state") {
                  // State changes: idle -> analyzing -> thinking -> responding
                  if (
                    event.state === "thinking" ||
                    event.state === "analyzing"
                  ) {
                    statusBadge.innerText =
                      event.state.charAt(0).toUpperCase() +
                      event.state.slice(1) +
                      "...";
                  }
                } else if (event.type === "workflow") {
                  const step = event.data?.step;
                  const status = event.data?.status;
                  const steps = event.data?.steps;

                  if (step && status) {
                    updateWorkflow(step, status);
                  } else if (steps && typeof steps === "object") {
                    Object.entries(steps).forEach(([key, value]) => {
                      updateWorkflow(key, value);
                    });
                  }
                } else if (event.type === "tool_start") {
                  // Tool execution started - Update badge only, don't show in list
                  const toolName = event.tool || event.data?.name || "tool";
                  statusBadge.innerText = `Running ${toolName}...`;
                  statusBadge.style.display = "flex";

                  if (toolName === "task_write") {
                    updateWorkflow("tasks", "active");
                  } else if (toolName === "tool_finder") {
                    updateWorkflow("tool_finder", "active");
                  } else if (!PLANNING_TOOLS.has(toolName)) {
                    updateWorkflow("tool_call", "active");
                  }
                } else if (event.type === "tool_result") {
                  // Tool completed - just log to console for debug
                  console.log("Tool result:", event.data);
                  const toolName = event.data?.name;

                  if (toolName === "task_write") {
                    updateWorkflow("tasks", "complete");
                  } else if (toolName === "tool_finder") {
                    updateWorkflow("tool_finder", "complete");
                  } else if (toolName && !PLANNING_TOOLS.has(toolName)) {
                    updateWorkflow("tool_call", "complete");
                  }
                } else if (event.type === "tasks") {
                  currentTasks = event.data?.tasks || [];
                  currentDependencies = event.data?.dependencies || {};
                  renderTasks();
                  updateWorkflow("tasks", "complete");
                } else if (
                  event.type === "response" ||
                  event.type === "content"
                ) {
                  // Final response - Show this!
                  let content =
                    event.content || event.data?.content || event.text || "";
                  if (content) {
                    // Format markdown-like syntax to HTML
                    const formatted = content
                      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
                      .replace(/`(.*?)`/g, "<code>$1</code>")
                      .replace(/\n/g, "<br>");

                    // Pass true to indicate content is already HTML-formatted
                    addMessage(formatted, "assistant", true);
                    statusBadge.innerText = "Completed";
                    statusBadge.classList.add("completed");
                  }
                } else if (event.type === "error") {
                  addMessage(
                    '<span style="color: #ff5f5f">Error: ' +
                      (event.error || event.data?.message || "Unknown error") +
                      "</span>",
                    "assistant",
                    true,
                  );
                  statusBadge.innerText = "Error";
                }
              } catch (e) {
                // Skip invalid JSON lines
                console.warn("Failed to parse event:", line, e);
              }
            }
          }

          // If no response was shown, show a default message
          if (messagesList.children.length === 0) {
            addMessage("Task completed.", "assistant");
          }
        } catch (e) {
          addMessage("Error: " + e.message, "assistant");
          statusBadge.innerText = "Error";
        }

        setThinking(false);
        setTimeout(() => {
          chatInput.placeholder = "Type a command or ask a question...";
        }, 3000);
      }

      // ===== Event Listeners =====
      chatInput.addEventListener("input", (e) => {
        const value = e.target.value;

        if (value.startsWith("/")) {
          const filter = value.slice(1);
          showCommandPalette(filter);
        } else {
          hideCommandPalette();
        }
      });

      chatInput.addEventListener("keydown", (e) => {
        const paletteVisible = commandPalette.style.display === "block";

        if (e.key === "Enter") {
          e.preventDefault();
          sendMessage();
        } else if (paletteVisible && e.key === "ArrowDown") {
          e.preventDefault();
          const items = commandPalette.querySelectorAll(".command-item");
          selectedCommandIndex = Math.min(
            selectedCommandIndex + 1,
            items.length - 1,
          );
          showCommandPalette(chatInput.value.slice(1));
        } else if (paletteVisible && e.key === "ArrowUp") {
          e.preventDefault();
          selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0);
          showCommandPalette(chatInput.value.slice(1));
        } else if (paletteVisible && e.key === "Escape") {
          e.preventDefault();
          hideCommandPalette();
        } else if (paletteVisible && e.key === "Tab") {
          e.preventDefault();
          const items = commandPalette.querySelectorAll(".command-item");
          if (items[selectedCommandIndex]) {
            chatInput.value = items[selectedCommandIndex].dataset.command;
          }
        }
      });

      settingsBtn.addEventListener("click", () => {
        if (window.settingsAPI && window.settingsAPI.open) {
          window.settingsAPI.open();
        }
      });

      // ===== Window Resizing =====
      const resizeObserver = new ResizeObserver((entries) => {
        for (let entry of entries) {
          const height = Math.ceil(entry.contentRect.height);
          // Add buffer for shadows/padding (approx 20px)
          if (window.windowAPI && window.windowAPI.resize) {
            window.windowAPI.resize(700, height + 20);
          }
        }
      });
      resizeObserver.observe(aceBar);
    </script>
  </body>
</html>
