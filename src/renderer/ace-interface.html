<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChatDock</title>
    <link rel="stylesheet" href="styles/ace-ui.css" />
    <link rel="stylesheet" href="styles/plan-panel.css" />
    <link rel="stylesheet" href="styles/console-panel.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@500&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <div class="ace-bar" id="aceBar">
      <!-- Input Row (Always Visible) -->
      <div class="input-row">
        <div class="bar-icon" id="mainIcon">
          <svg viewBox="0 0 24 24">
            <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="white" />
            <path
              d="M2 17L12 22L22 17"
              stroke="white"
              stroke-width="2"
              fill="none"
            />
            <path
              d="M2 12L12 17L22 12"
              stroke="white"
              stroke-width="2"
              fill="none"
            />
          </svg>
        </div>

        <input
          type="text"
          class="bar-input"
          id="chatInput"
          placeholder="Ask anything..."
          autocomplete="off"
          autofocus
        />

        <div class="bar-actions">
          <button class="settings-btn" id="settingsBtn" title="Settings">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
              <path
                d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.56-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.03-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"
              />
            </svg>
          </button>

          <div class="action-badge" id="statusBadge" style="display: none">
            Ready
          </div>

          <button class="btn-console-toggle" id="btnConsoleToggle" title="Show OS Console">
            <span>Console</span>
          </button>

          <!-- YOLO Toggle (Global) -->
          <div
            class="yolo-toggle"
            id="yoloToggle"
            title="YOLO Mode: Warning - may auto-approve steps in future"
          >
            <div class="toggle-switch"></div>
            <span>YOLO</span>
          </div>
        </div>
      </div>

      <!-- Command Palette (shown when typing /) -->
      <div class="command-palette" id="commandPalette" style="display: none">
        <!-- Dynamic command items -->
      </div>

      <!-- Plan Panel (Hidden by default) -->
      <div class="plan-panel hidden" id="planPanel">
        <div class="plan-header">
          <div class="plan-title">
            <span id="planTitle">üìã Current Plan</span>
            <span class="status-badge hidden" id="statusBadgePlan"
              >Proposed</span
            >
            <span class="locked-badge hidden" id="lockedBadge">Locked</span>
          </div>
          <div class="plan-meta" id="planMeta">0 steps</div>
        </div>

        <div class="plan-error hidden" id="planError"></div>

        <div class="plan-goal" id="planGoal"></div>

        <div class="plan-steps" id="planSteps">
          <!-- Steps injected here -->
        </div>

        <div class="plan-actions" id="planActions">
          <div class="action-group">
            <button
              class="btn-plan btn-accept"
              id="btnAccept"
              title="Accept and proceed with plan"
            >
              ‚úì Accept
            </button>
            <button
              class="btn-plan btn-edit"
              id="btnEdit"
              title="Edit this plan"
            >
              ‚úé Edit
            </button>
            <button
              class="btn-plan btn-reject"
              id="btnReject"
              title="Discard this plan"
            >
              ‚úï Reject
            </button>
          </div>
        </div>
      </div>

      <!-- Console Panel (Hidden by default) -->
      <div class="console-panel hidden" id="consolePanel">
        <div class="console-header">
          <div class="console-title">
            <span>üíª OS Console</span>
          </div>
        </div>
        <div class="console-body">
          <div class="run-list" id="runList">
            <!-- Run items injected here -->
          </div>
          <div class="run-detail" id="runDetail">
            <div class="empty-state" id="consoleEmptyState">
              <span>Select a command run to view output</span>
            </div>
            <div class="run-detail-content hidden" id="runDetailContent">
                <div class="run-detail-header">
                  <div class="run-time" id="detailTime"></div>
                  <div class="run-detail-cmd" id="detailCmd"></div>
                </div>
                <div class="run-output">
                  <div class="output-section">
                    <div class="output-label">Stdout</div>
                    <div class="output-content stdout-content" id="detailStdout"></div>
                  </div>
                  <div class="output-section">
                    <div class="output-label">Stderr</div>
                    <div class="output-content stderr-content" id="detailStderr"></div>
                  </div>
                </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Expanded Content -->
      <div class="expanded-content" id="expandedList">
        <div class="messages-list" id="messagesList"></div>
      </div>
    </div>

    <script>
      // ===== Configuration =====
      const CHAT_BASE =
        (window.__CHAT_BASE__ &&
          window.__CHAT_BASE__.get &&
          window.__CHAT_BASE__.get()) ||
        "http://127.0.0.1:3001";
      const CHAT_AUTH =
        (window.__CHAT_AUTH__ &&
          window.__CHAT_AUTH__.get &&
          window.__CHAT_AUTH__.get()) ||
        {};

      // ===== DOM Elements =====
      const aceBar = document.getElementById("aceBar");
      const chatInput = document.getElementById("chatInput");
      const expandedList = document.getElementById("expandedList");
      const messagesList = document.getElementById("messagesList");
      const mainIcon = document.getElementById("mainIcon");
      const statusBadge = document.getElementById("statusBadge");
      const settingsBtn = document.getElementById("settingsBtn");
      const commandPalette = document.getElementById("commandPalette");
      const btnConsoleToggle = document.getElementById("btnConsoleToggle");

      // Plan Panel Elements
      const planPanel = document.getElementById("planPanel");
      const planGoal = document.getElementById("planGoal");
      const planSteps = document.getElementById("planSteps");
      const planMeta = document.getElementById("planMeta");
      const lockedBadge = document.getElementById("lockedBadge");
      const btnAccept = document.getElementById("btnAccept");
      const btnReject = document.getElementById("btnReject");
      const btnEdit = document.getElementById("btnEdit");
      const planActions = document.getElementById("planActions");
      const yoloToggle = document.getElementById("yoloToggle");

      // Console Panel Elements
      const consolePanel = document.getElementById("consolePanel");
      const runList = document.getElementById("runList");
      const runDetailContent = document.getElementById("runDetailContent");
      const consoleEmptyState = document.getElementById("consoleEmptyState");
      const detailTime = document.getElementById("detailTime");
      const detailCmd = document.getElementById("detailCmd");
      const detailStdout = document.getElementById("detailStdout");
      const detailStderr = document.getElementById("detailStderr");

      // ===== State =====
      let isProcessing = false;
      let currentModels = [];
      let currentModel = "";
      let selectedCommandIndex = 0;
      let isYoloMode = false;
      let pollInterval = null;
      let lastPlanJson = ""; // for change detection
      let pendingPlanProceed = false;
      let isConsoleOpen = false;
      let consoleRuns = [];
      let selectedRunId = null;
      let consolePollInterval = null;

      // ===== Available Commands =====
      const COMMANDS = [
        { name: "/model", description: "Switch AI model", icon: "ü§ñ" },
        { name: "/clear", description: "Clear conversation", icon: "üóëÔ∏è" },
        { name: "/help", description: "Show help", icon: "‚ùì" },
        { name: "/memory", description: "Memory tools (search, config)", icon: "üß†" },
        { name: "/skills", description: "Skills management", icon: "üß∞" },
        { name: "/stats", description: "Plan stats", icon: "üìä" },
        { name: "/channels", description: "Channel sessions", icon: "üì°" },
      ];

      // ===== Initial Setup =====
      chatInput.focus();
      loadModels();
      startPlanPolling();

      // ===== Helper Functions =====
      function getAuthHeaders() {
        return CHAT_AUTH || {};
      }

      async function loadModels() {
        try {
          const res = await fetch(`${CHAT_BASE}/models`, {
            headers: getAuthHeaders(),
          });
          const data = await res.json();
          currentModels = data.models || [];
          currentModel =
            data.lastModel ||
            (currentModels.length > 0 ? currentModels[0] : "");
        } catch (e) {
          console.error("Failed to load models:", e);
        }
      }

      function setThinking(thinking) {
        isProcessing = thinking;
        if (thinking) {
          mainIcon.classList.add("loading");
          mainIcon.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 4V2M12 20v2M4 12H2m20 0h-2m-2.05-5.95l-1.41-1.41M5.46 19.95l-1.41-1.41M18.54 18.54l1.41 1.41M5.46 4.05l-1.41 1.41" stroke="currentColor" stroke-width="2" fill="none"/></svg>`;
          statusBadge.style.display = "flex";
          statusBadge.innerText = "Thinking...";
          settingsBtn.style.display = "none";
        } else {
          mainIcon.classList.remove("loading");
          mainIcon.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 2L2 7L12 12L22 7L12 2Z" fill="white"/><path d="M2 17L12 22L22 17" stroke="white" stroke-width="2" fill="none"/><path d="M2 12L12 17L22 12" stroke="white" stroke-width="2" fill="none"/></svg>`;
          statusBadge.style.display = "none";
          settingsBtn.style.display = "flex";
        }
      }

      function expand(shouldExpand) {
        if (shouldExpand) {
          aceBar.classList.add("expanded");
        } else {
          aceBar.classList.remove("expanded");
        }
      }

      function showCommandPalette(filter = "") {
        if (filter.toLowerCase().startsWith("model")) {
          showModelSelector();
          return;
        }

        const filtered = COMMANDS.filter(
          (cmd) =>
            cmd.name.toLowerCase().includes(filter.toLowerCase()) ||
            cmd.description.toLowerCase().includes(filter.toLowerCase()),
        );

        if (filtered.length === 0) {
          hideCommandPalette();
          return;
        }

        commandPalette.innerHTML = filtered
          .map(
            (cmd, idx) => `
          <div class="command-item ${idx === selectedCommandIndex ? "selected" : ""}" data-command="${cmd.name}">
            <span class="command-icon">${cmd.icon}</span>
            <div class="command-info">
              <div class="command-name">${cmd.name}</div>
              <div class="command-desc">${cmd.description}</div>
            </div>
          </div>
        `,
          )
          .join("");

        commandPalette.style.display = "block";
        setTimeout(() => commandPalette.classList.add("visible"), 10);
        expand(true);

        commandPalette.querySelectorAll(".command-item").forEach((item) => {
          item.addEventListener("click", () => {
            chatInput.value = item.dataset.command;
            hideCommandPalette();
            if (item.dataset.command === "/model") {
              showModelSelector();
            } else {
              sendMessage();
            }
          });
        });
      }

      function showModelSelector() {
        if (currentModels.length === 0) {
          commandPalette.innerHTML =
            '<div class="command-item"><div class="command-info"><div class="command-desc">No models found...</div></div></div>';
          commandPalette.style.display = "block";
          setTimeout(() => commandPalette.classList.add("visible"), 10);
          return;
        }

        commandPalette.innerHTML = `
          <div class="model-list">
            ${currentModels
              .map(
                (model) => `
              <div class="model-item ${model === currentModel ? "active" : ""}" data-model="${model}">
                <span>${model}</span>
                ${model === currentModel ? '<span class="checkmark">‚úì</span>' : ""}
              </div>
            `,
              )
              .join("")}
          </div>
        `;

        commandPalette.style.display = "block";
        setTimeout(() => commandPalette.classList.add("visible"), 10);
        expand(true);

        commandPalette.querySelectorAll(".model-item").forEach((item) => {
          item.addEventListener("click", async () => {
            const selectedModel = item.dataset.model;
            currentModel = selectedModel;
            await fetch(`${CHAT_BASE}/models/selected`, {
              method: "POST",
              headers: {
                ...getAuthHeaders(),
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ model: selectedModel }),
            });
            chatInput.value = "";
            hideCommandPalette();
            messagesList.innerHTML = "";
            addMessage(`Switched to model: ${selectedModel}`, "assistant");
          });
        });
      }

      function hideCommandPalette() {
        commandPalette.classList.remove("visible");
        setTimeout(() => {
          commandPalette.style.display = "none";
          commandPalette.innerHTML = "";
        }, 250);
        selectedCommandIndex = 0;
      }

      function addMessage(text, type = "assistant") {
        expand(true);
        const msg = document.createElement("div");
        msg.className = `message ${type}`;

        let safe = escapeHtml(text)
          .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
          .replace(/`(.*?)`/g, "<code>$1</code>")
          .replace(/\n/g, "<br>");

        msg.innerHTML = `<div class="message-content">${safe}</div>`;
        messagesList.appendChild(msg);
        expandedList.scrollTop = expandedList.scrollHeight;
        return msg;
      }

      function updateLastAssistantMessage(text) {
        const lastMsg = messagesList.lastElementChild;
        if (lastMsg && lastMsg.classList.contains("assistant")) {
          const content = lastMsg.querySelector(".message-content");
          let safe = escapeHtml(text)
            .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
            .replace(/`(.*?)`/g, "<code>$1</code>")
            .replace(/\n/g, "<br>");
          content.innerHTML = safe;
        } else {
          addMessage(text, "assistant");
        }
        expandedList.scrollTop = expandedList.scrollHeight;
      }

      function escapeHtml(text) {
        if (!text) return "";
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#039;",
        };
        return text.replace(/[&<>"']/g, (m) => map[m]);
      }

      async function sendToServer(messageText) {
        setThinking(true);
        expand(true);
        hideCommandPalette();

        // Clear previous messages to show ONLY the latest agent message
        messagesList.innerHTML = "";

        try {
          const response = await fetch(`${CHAT_BASE}/chat`, {
            method: "POST",
            headers: {
              ...getAuthHeaders(),
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ message: messageText, model: currentModel }),
          });

          if (!response.ok) throw new Error(`Server error: ${response.status}`);

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let assistantMsg = "";
          addMessage("", "assistant"); // Placeholder for streaming

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            assistantMsg += decoder.decode(value, { stream: true });
            updateLastAssistantMessage(assistantMsg);
          }
        } catch (e) {
          addMessage("Error: " + e.message, "assistant");
        }
        setThinking(false);
      }

      function mapSlashCommand(text) {
        const raw = text.slice(1).trim();
        const parts = raw.split(/\s+/);
        const root = (parts[0] || "").toLowerCase();
        const args = raw.slice(root.length).trim();

        if (root === "memory") {
          if (!args) return "memory status";
          if (args.startsWith("search ")) return `search memories ${args.slice(7)}`;
          if (args.startsWith("recall ")) return `recall ${args.slice(7)}`;
          if (args === "list") return "list memories";
          if (args.startsWith("show ")) return `show memory ${args.slice(5)}`;
          if (args.startsWith("forget ")) return `forget memory ${args.slice(7)}`;
          if (args.startsWith("delete ")) return `forget memory ${args.slice(7)}`;
          if (args.startsWith("auto ")) return `auto memory ${args.slice(5)}`;
          if (args === "config") return "memory config";
          if (args === "config reset") return "reset memory config";
          if (args.startsWith("config set ")) return `set memory ${args.slice(11)}`;
          return null;
        }

        if (root === "skills") {
          if (!args || args === "list") return "list skills";
          if (args.startsWith("install ")) return `install skill ${args.slice(8)}`;
          if (args.startsWith("remove ")) return `remove skill ${args.slice(7)}`;
          return null;
        }

        if (root === "stats") {
          return "plan stats";
        }

        if (root === "channels") {
          if (!args || args === "list") return "list channels";
          if (args.startsWith("register ")) return `register channel ${args.slice(9)}`;
          if (args.startsWith("remove ")) return `remove channel ${args.slice(7)}`;
          return null;
        }

        return null;
      }

      async function sendMessage() {
        const text = chatInput.value.trim();
        if (!text || isProcessing) return;

        if (text.startsWith("/")) {
          chatInput.value = "";
          hideCommandPalette();
          if (text === "/clear") {
            messagesList.innerHTML = "";
            expand(false);
          } else if (text === "/model") {
            showModelSelector();
          } else if (text === "/help") {
            addMessage(
              "Available commands:\n/model - Switch AI model\n/clear - Clear chat\n/help - Show this help\n/memory - Memory tools\n/skills - Skills management\n/stats - Plan stats\n/channels - Channel sessions",
              "assistant",
            );
          } else {
            const mapped = mapSlashCommand(text);
            if (!mapped) {
              addMessage("Unknown slash command. Try /help.", "assistant");
              return;
            }
            await sendToServer(mapped);
          }
          return;
        }

        chatInput.value = "";
        await sendToServer(text);
      }

      chatInput.addEventListener("input", (e) => {
        if (e.target.value.startsWith("/"))
          showCommandPalette(e.target.value.slice(1));
        else hideCommandPalette();
      });

      chatInput.addEventListener("keydown", (e) => {
        const paletteVisible = commandPalette.style.display === "block";
        if (e.key === "Enter") {
          e.preventDefault();
          sendMessage();
        } else if (paletteVisible && e.key === "ArrowDown") {
          e.preventDefault();
          const items = commandPalette.querySelectorAll(".command-item");
          selectedCommandIndex = Math.min(
            selectedCommandIndex + 1,
            items.length - 1,
          );
          showCommandPalette(chatInput.value.slice(1));
        } else if (paletteVisible && e.key === "ArrowUp") {
          e.preventDefault();
          selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0);
          showCommandPalette(chatInput.value.slice(1));
        } else if (e.key === "Escape") {
          hideCommandPalette();
        }
      });

      settingsBtn.addEventListener("click", () => {
        if (window.settingsAPI && window.settingsAPI.open)
          window.settingsAPI.open();
      });

      const resizeObserver = new ResizeObserver((entries) => {
        for (let entry of entries) {
          const height = Math.ceil(entry.contentRect.height);
          if (window.windowAPI && window.windowAPI.resize)
            window.windowAPI.resize(700, height + 20);
        }
      });
      resizeObserver.observe(aceBar);

      // ===== Plan Panel Logic =====

      function startPlanPolling() {
        // Poll every 2 seconds for plan updates
        fetchPlanStatus();
        pollInterval = setInterval(fetchPlanStatus, 2000);
      }

      async function fetchPlanStatus() {
        try {
          const res = await fetch(`${CHAT_BASE}/plan/active`, {
            headers: getAuthHeaders(),
          });
          if (!res.ok) return;
          const data = await res.json();
          renderPlanPanel(data);
        } catch (e) {
          console.warn("Plan polling failed:", e);
        }
      }

      /**
       * Render the plan panel with proper state machine behavior
       * Plan States: none | proposed | accepted | locked | error
       */
      /**
       * Render the plan panel with proper state machine behavior
       * Plan States: none | proposed | accepted | locked | error
       */
      function renderPlanPanel(data) {
        // Content change detection to avoid flickering DOM updates
        const currentJson = JSON.stringify(data);
        if (currentJson === lastPlanJson) return;
        lastPlanJson = currentJson;

        // DOM elements for plan panel
        const statusBadgePlan = document.getElementById("statusBadgePlan");
        const planError = document.getElementById("planError");

        // Handle NONE state - no plan
        if (!data.hasPlan || !data.plan) {
          pendingPlanProceed = false;
          planPanel.classList.add("hidden");
          return;
        }

        const plan = data.plan;
        
        // --- STRICT VALIDITY CHECK ---
        // A plan is INVALID only if: NO plan object, OR goal empty, OR steps empty
        const isValid = plan && plan.goal && Array.isArray(plan.steps) && plan.steps.length > 0;
        
        if (!isValid) {
            // Force error state if validation fails
            data.status = "error";
        }

        // Show Panel
        planPanel.classList.remove("hidden");
        // Ensure expanded view when plan is active, unless user collapsed it (TODO: persistence)
        expand(true); 

        // Get plan state
        const rawStatus = data.status || "proposed";
        let status = rawStatus;
        if (pendingPlanProceed && status === "proposed") {
          status = "executing";
        }
        // Locked must be explicitly true
        const isLocked = data.locked === true;

        // YOLO Mode: Hide actions if active
        if (isYoloMode) {
            planActions.classList.add("hidden");
        } else {
            planActions.classList.remove("hidden");
        }

        // Update header
        planGoal.textContent = plan.goal || "No Goal Set";
        planMeta.textContent = `${plan.steps.length} step${plan.steps.length !== 1 ? "s" : ""}`;

        // Reset all badges and error state
        lockedBadge.classList.add("hidden");
        statusBadgePlan.classList.add("hidden");
        planError.classList.add("hidden");

        // Show status badge
        statusBadgePlan.textContent =
          status.charAt(0).toUpperCase() + status.slice(1);
        statusBadgePlan.className = `status-badge ${status}`;
        statusBadgePlan.classList.remove("hidden");

        // Show locked badge ONLY if explicitly locked
        if (isLocked) {
          lockedBadge.classList.remove("hidden");
        }

        // ===== UI BEHAVIOR PER STATE =====
        // Reset button states
        btnAccept.disabled = false;
        btnEdit.disabled = false;
        btnReject.disabled = false;
        btnAccept.classList.remove("hidden");
        btnEdit.classList.remove("hidden");
        btnReject.classList.remove("hidden");
        btnAccept.textContent = "‚úì Accept";
        btnReject.textContent = "‚úï Reject";

        if (status !== "proposed") {
          pendingPlanProceed = false;
        }

        switch (status) {
          case "proposed":
            // Accept, Edit, Reject all enabled
            btnAccept.disabled = false;
            btnEdit.disabled = false;
            btnReject.disabled = false;
            
            // YOLO AUTO-EXECUTE
            if (isYoloMode) {
                console.log("YOLO Mode: Auto-accepting plan...");
                // Use setTimeout to allow UI to render first
                setTimeout(() => {
                    const proceedInput = "proceed with plan";
                    // Only send if we haven't already (simple debounce)
                    if (chatInput.value !== proceedInput) {
                        chatInput.value = proceedInput;
                        sendMessage();
                    }
                }, 500);
            }
            break;

          case "accepted":
            // Accept hidden/disabled (already accepted), Edit enabled, Reject enabled
            btnAccept.classList.add("hidden");
            btnAccept.disabled = true;
            btnEdit.disabled = false;
            btnReject.disabled = false;
            break;

          case "executing":
            // Hide all actions while executing
            btnAccept.classList.add("hidden");
            btnEdit.classList.add("hidden");
            btnReject.classList.add("hidden");
            statusBadgePlan.textContent = "‚öôÔ∏è Executing...";
            statusBadgePlan.className = "status-badge executing";
            break;

          case "paused":
            // Show main Accept as "Allow Step N" and keep Reject as "Cancel Plan"
            btnAccept.classList.remove("hidden");
            btnAccept.disabled = false;
            btnEdit.classList.add("hidden");
            btnReject.classList.remove("hidden");
            btnReject.textContent = "‚úï Cancel Plan";

            const pendingId = data.pendingStepPermission ? data.pendingStepPermission.stepNumber : "";
            btnAccept.textContent = `‚úì Allow Step ${pendingId}`;
            
            statusBadgePlan.textContent = "‚è∏ Paused";
            statusBadgePlan.className = "status-badge paused";
            break;
            
          case "completed":
             // All done. Show minimal completion status.
             btnAccept.classList.add("hidden");
             btnEdit.classList.add("hidden");
             btnReject.classList.add("hidden");
             statusBadgePlan.textContent = "Request completed";
             statusBadgePlan.className = "status-badge completed"; 
             
             setTimeout(() => {
                 planPanel.classList.add("hidden");
                 
                 // Explicitly sync backend state to cleared
                 fetch("http://localhost:3001/plan/reset", {
                     method: "POST",
                     headers: { "Content-Type": "application/json" },
                     body: JSON.stringify({ sessionId: sessionId })
                 }).catch(e => console.warn("Failed to reset plan:", e));

                 statusBadge.style.display = 'flex';
                 statusBadge.innerText = 'Request completed';
                 statusBadge.className = 'action-badge success';
                 setTimeout(() => { 
                     statusBadge.style.display = 'none'; 
                     statusBadge.className = 'action-badge';
                 }, 3000);
             }, 3000);
             break;

          case "locked":
            // Accept hidden, Edit disabled, Reject disabled (can't modify locked plan)
            btnAccept.classList.add("hidden");
            btnAccept.disabled = true;
            btnEdit.disabled = true;
            btnEdit.classList.add("hidden");
            btnReject.disabled = true;
            btnReject.classList.add("hidden");
            break;

          case "error":
            // All action buttons hidden, show error message
            btnAccept.classList.add("hidden");
            btnEdit.classList.add("hidden");
            btnReject.classList.remove("hidden"); // Allow rejection to clear error
            btnReject.textContent = "‚úï Clear";

            // Show error message
            planError.textContent =
              "The active plan is invalid (missing goal or steps). Please generate a new plan.";
            planError.classList.remove("hidden");
            break;

          default:
            // Default to proposed behavior
            break;
        }

        // Render Steps
        planSteps.innerHTML = plan.steps
          .map((step) => {
            const isExecuted = (data.executedSteps || []).includes(step.id);
            const isSkipped = (data.skippedSteps || []).includes(step.id);
            const isRunning = data.executingStepId === step.id;
            const statusData = (data.stepStatus && data.stepStatus[step.id]) || null;
            const status = isSkipped
              ? "skipped"
              : statusData?.status || (isExecuted ? "done" : isRunning ? "running" : "queued");
            const latencyMs = statusData?.latencyMs;
            const output = statusData?.output;
            const stdout = statusData?.stdout;
            const stderr = statusData?.stderr;

            let classes = "plan-step";
            let icon = "‚óã"; // queued
            if (status === "done") {
              classes += " done";
              icon = "‚úì";
            } else if (status === "failed") {
              classes += " failed";
              icon = "‚úï";
            } else if (status === "running") {
              classes += " running";
              icon = `<div class="spinner"></div>`;
            } else if (status === "paused") {
              classes += " paused-step";
              icon = `<span class="icon-paused">‚è∏</span>`;
            } else if (status === "skipped") {
              classes += " skipped";
              icon = "‚àí";
            } else {
              classes += " queued";
            }

            let outputBlocks = "";
            const parts = [];
            if (output) {
              parts.push(`<div class="step-output-block"><div class="output-label">Response</div><pre>${escapeHtml(output)}</pre></div>`);
            }
            if (stdout) {
              parts.push(`<div class="step-output-block"><div class="output-label">Stdout</div><pre>${escapeHtml(stdout)}</pre></div>`);
            }
            if (stderr) {
              parts.push(`<div class="step-output-block error"><div class="output-label">Stderr</div><pre>${escapeHtml(stderr)}</pre></div>`);
            }
            if (parts.length) {
              const openAttr = status === "failed" ? " open" : "";
              outputBlocks = `<details class="step-output"${openAttr}><summary>Output</summary>${parts.join("")}</details>`;
            }

            const meta = latencyMs ? `<span class="step-meta">${Math.round(latencyMs)}ms</span>` : "";

            return `<div class="${classes}">
              <div class="step-main">
                <span class="step-id">${step.id}.</span>
                <span class="step-type">${step.type}</span>
                <span class="step-desc">${escapeHtml(step.description)}</span>
                ${meta}
                <span class="step-status">${icon}</span>
              </div>
              ${outputBlocks}
            </div>`;
          })
          .join("");
      }
      
      // ===== Console Panel Logic =====
      async function fetchOSRuns() {
        try {
          const res = await fetch(`${CHAT_BASE}/os/runs`);
          const data = await res.json();
          consoleRuns = data;
          updateConsoleUI();
        } catch (err) {
          console.error("Failed to fetch OS runs:", err);
        }
      }

      function updateConsoleUI() {
        if (!isConsoleOpen) return;

        // Render List
        if (consoleRuns.length === 0) {
            runList.innerHTML = `<div class="empty-state">No commands executed yet</div>`;
        } else {
            runList.innerHTML = consoleRuns.map(run => {
                const isActive = selectedRunId === run.id;
                let statusIcon = "‚óã";
                if (run.status === "running") statusIcon = `<div class="spinner-small"></div>`;
                else if (run.status === "success") statusIcon = "‚úì";
                else if (run.status === "error") statusIcon = "‚úï";

                const timeStr = new Date(run.timestampStarted).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                
                return `
                    <div class="run-item ${isActive ? 'active' : ''}" onclick="selectRun('${run.id}')">
                        <div class="run-item-top">
                            <span class="run-status-icon">${statusIcon}</span>
                            <span class="run-time">${timeStr}</span>
                        </div>
                        <div class="run-cmd">${escapeHtml(run.command)}</div>
                    </div>
                `;
            }).join("");
        }

        // Render Detail
        const selectedRun = consoleRuns.find(r => r.id === selectedRunId);
        if (selectedRun) {
            consoleEmptyState.classList.add("hidden");
            runDetailContent.classList.remove("hidden");
            
            detailTime.textContent = `${new Date(selectedRun.timestampStarted).toLocaleString()} (${selectedRun.status})`;
            detailCmd.textContent = selectedRun.command;
            
            // Standardize output (handling nulls)
            const stdout = selectedRun.stdout || (selectedRun.status === 'running' ? '...waiting for output...' : '(No output)');
            const stderr = selectedRun.stderr || '';
            
            detailStdout.textContent = stdout;
            detailStderr.textContent = stderr;
        } else {
            consoleEmptyState.classList.remove("hidden");
            runDetailContent.classList.add("hidden");
        }
      }

      window.selectRun = (id) => {
        selectedRunId = id;
        updateConsoleUI();
      }

      function toggleConsole() {
        isConsoleOpen = !isConsoleOpen;
        btnConsoleToggle.classList.toggle("active", isConsoleOpen);
        consolePanel.classList.toggle("hidden", !isConsoleOpen);
        
        if (isConsoleOpen) {
          expand(true);
          fetchOSRuns();
          // Auto-poll when open
          if (!consolePollInterval) {
            consolePollInterval = setInterval(fetchOSRuns, 2000);
          }
        } else {
          if (consolePollInterval) {
            clearInterval(consolePollInterval);
            consolePollInterval = null;
          }
        }
      }

      btnConsoleToggle.addEventListener("click", toggleConsole);

      // Actions
      btnAccept.addEventListener("click", () => {
        const status = lastPlanJson ? JSON.parse(lastPlanJson).status : "";
        const data = lastPlanJson ? JSON.parse(lastPlanJson) : {};

        if (status === "paused" && data.pendingStepPermission) {
            chatInput.value = `allow step ${data.pendingStepPermission.stepNumber}`;
            sendMessage();
            return;
        }

        // Immediate UI feedback
        pendingPlanProceed = true;
        planActions.classList.add("hidden");
        const statusBadgePlan = document.getElementById("statusBadgePlan");
        statusBadgePlan.textContent = "‚öôÔ∏è Executing...";
        statusBadgePlan.className = "status-badge executing";

        if (isYoloMode) {
          // Future: could append flag
        }
        // Send explicit command
        chatInput.value = "proceed with plan";
        sendMessage();
      });

      btnReject.addEventListener("click", () => {
        chatInput.value = "cancel plan";
        sendMessage();
      });

      btnEdit.addEventListener("click", () => {
        // Simple prompt for now
        const changes = prompt("Describe changes to the plan:");
        if (changes) {
          chatInput.value = `Edit this plan: ${changes}`;
          sendMessage();
        }
      });

      yoloToggle.addEventListener("click", () => {
        isYoloMode = !isYoloMode;
        if (isYoloMode) {
          yoloToggle.classList.add("active");
          yoloToggle.title =
            "YOLO Mode Active: Warning, steps may auto-execute";
        } else {
          yoloToggle.classList.remove("active");
          yoloToggle.title =
            "YOLO Mode: Warning - may auto-approve steps in future";
        }
        // Force re-render to hide/show buttons if plan is active
        lastPlanJson = ""; 
        fetchPlanStatus();
      });
    </script>
  </body>
</html>
